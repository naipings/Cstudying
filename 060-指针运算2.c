#include <stdio.h>

int main(void)
{
	char ac[] = {0,1,2,3,4,5,6,7,8,9,};
	char *p = ac;
	printf("p  =%p\n", p);
	printf("p+1=%p\n", p+1);
	//*p -> ac[0]
	//*(p+1) -> ac[1]  //由于*为单目运算符，它的优先级比+高，所以在p+1外面加上一个()，让+先运算
	//*(p+n) <-> ac[n] //即：*(p+n)和 ac[n]是等价的
	printf("*(p+1)=%d\n", *(p+1));
	
	int ai[] = {0,1,2,3,4,5,6,7,8,9,};
	int *q = ai;
	printf("q  =%p\n", q);
	printf("q+1=%p\n", q+1);
	printf("*(q+1)=%d\n", *(q+1));

	return 0;
}

/*
1=1=2?
给一个指针加1表示要让指针指向下一个变量
	int a[10];
	int *p = a;
	*(p+1) ——> a[1]
如果指针不是指向一片连续分配的空间（如数组），则这种运算没有意义
*/

/*
指针运算：
这些算术运算可以对指针做：
	给指针加 、减一个整数（+，+=，-，-=）
	递增递减（++/--）
	两个指针相减
*/
/*
#include <stdio.h>

int main(void)
{
	char ac[] = {0,1,2,3,4,5,6,7,8,9,};
	char *p = ac;
	char *p1 = &ac[5];
	printf("p1-p=%d\n", p1-p);

	int ai[] = {0,1,2,3,4,5,6,7,8,9,};
	int *q = ai;
	int *q1 = &ai[6];
	printf("q  =%p\n", q);
	printf("q1 =%p\n", q1);
	printf("q1-q=%d\n", q1-q); //所以当两个指针相减的时候，结果输出不简单是两个地址值的差，而是两个地址值相减后，再除以它们对应的那个sizeof类型后的值
	
	return 0;
}
*/

/*
*p++
取出p所指的那个数据来，完事之后顺便把p移到下一个位置去
*的优先级虽然高，但是没有++高
常用于数组类的连续空间操作
在某些CPU上，这可以直接被翻译成一条汇编指令
*/
/*
#include <stdio.h>

int main(void)
{
	char ac[] = {0,1,2,3,4,5,6,7,8,9,-1}; //-1是为了退出循环而放的值
	char *p = &ac[0];
	
	//以下三种遍历数组的方式是等价的。第一种是我们很早就学习了的，另外两种是运用指针以及*p++运算来实现的
	int i;
	for ( i=0; i<sizeof(ac)/sizeof(ac[0]); i++ ) {
		printf("%d\n", ac[i]);
	}
	
	for ( p=ac; *p!=-1; p++ ) {
		printf("%d\n", *p);	
	}
	
	for ( p=ac; *p!=-1; ) {
		printf("%d\n", *p++);	
	}
	
	//并且我们前面已经定义了char *p = &ac[0]; 所以可以直接用while循环
	while ( *p != -1) {
		printf("%d\n", *p++);
	}

	return 0;

}
*/

/*
指针比较：
<，<=，==，>，>=，!=都可以对指针做
（实际上是）比较它们在内存中的地址
数组中的单元的地址肯定是线性递增的
*/

/*
0地址：
当然我们的内存中有0地址，但是0地址通常是个不能随便碰的地址
所以我们的指针不应该具有0值
因此可以用0地址来表示特殊的事情：
	返回的指针是无效的
	指针没有被真正初始化（先初始化为0）
NULL是一个预定定义的符号，表示0地址
	有的编译器不愿意你用0来表示0地址
*/

/*
指针的类型：
无论指向什么类型，所有的指针的大小都是一样的，因为都是地址
但是指向不同类型的指针是不能直接互相赋值的
这是为了避免用错指针
*/
/*
指针的类型转换：（初学者不建议做这种事情）
void* 表示不知道指向什么东西的指针
	计算时与char*相同（但不相通）
指针也可以转换类型
	int *p = &i;  void*q = (void*)p;
这并没有改变p所指的变量的类型，而是让后人用不同的眼光通过p看它所指的变量
	我不再当你是int啦，我认为你就是个void！
*/

/*
用指针来做什么：

需要传入较大的数据时用作参数
传入数组后对数组做操作
函数返回不止一个结果
	需要用函数来修改不止一个变量
动态申请的内存···
*/

